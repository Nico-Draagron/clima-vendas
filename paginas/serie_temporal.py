# ============================================================================
# üìà pages/serie_temporal.py - AN√ÅLISE DE S√âRIE TEMPORAL
# ============================================================================

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import scipy.stats as stats
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller, acf, pacf
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from scipy import signal
from sklearn.metrics import mean_squared_error, mean_absolute_error
import warnings
warnings.filterwarnings('ignore')

class SerieTemporalPage:
    """P√°gina completa de an√°lise de s√©rie temporal"""
    
    def __init__(self, store_manager):
        self.store_manager = store_manager
    
    def render(self):
        """Renderiza p√°gina principal de s√©rie temporal"""
        
        st.markdown("# üìà An√°lise de S√©rie Temporal")
        st.markdown("**An√°lise detalhada dos padr√µes temporais nas vendas e identifica√ß√£o de tend√™ncias e sazonalidade**")
        
        # Carregar dados
        stores = self.store_manager.get_available_stores()
        
        if not stores:
            st.error("‚ùå Nenhuma loja configurada. Configure uma loja no painel administrativo.")
            return
        
        # Sele√ß√£o de loja
        store_options = {f"{info['display_name']} ({store_id})": store_id 
                        for store_id, info in stores.items()}
        
        selected_display = st.selectbox(
            "üè™ Escolha uma loja para an√°lise temporal:",
            options=list(store_options.keys())
        )
        
        selected_store_id = store_options[selected_display]
        
        # Carregar dados da loja
        df = self.store_manager.load_store_data(selected_store_id)
        
        if df is None or df.empty:
            st.error("‚ùå N√£o foi poss√≠vel carregar dados da loja")
            return
        
        store_info = stores[selected_store_id]
        value_col = store_info['value_column']
        
        if value_col not in df.columns:
            st.error(f"‚ùå Coluna de vendas '{value_col}' n√£o encontrada nos dados")
            return
        
        # Preparar dados
        df = self._prepare_time_series_data(df, value_col)
        
        if df is None or len(df) < 30:
            st.error("‚ùå Dados insuficientes para an√°lise temporal (m√≠nimo 30 observa√ß√µes)")
            return
        
        # Tabs principais
        tab1, tab2, tab3, tab4, tab5 = st.tabs([
            "üìä Vis√£o Geral",
            "üîç Decomposi√ß√£o",
            "üìà Tend√™ncias",
            "üîÑ Sazonalidade",
            "üìâ Autocorrela√ß√£o"
        ])
        
        with tab1:
            self._render_overview(df, value_col, store_info['display_name'])
        
        with tab2:
            self._render_decomposition(df, value_col)
        
        with tab3:
            self._render_trend_analysis(df, value_col)
        
        with tab4:
            self._render_seasonality_analysis(df, value_col)
        
        with tab5:
            self._render_autocorrelation_analysis(df, value_col)
    
    def _prepare_time_series_data(self, df, value_col):
        """Prepara dados para an√°lise de s√©rie temporal"""
        
        # Converter data
        df['data'] = pd.to_datetime(df['data'])
        
        # Ordenar por data
        df = df.sort_values('data')
        
        # Verificar se h√° dados duplicados por data
        duplicates = df.duplicated(subset=['data']).sum()
        if duplicates > 0:
            st.warning(f"‚ö†Ô∏è {duplicates} datas duplicadas encontradas. Agregando por soma.")
            df = df.groupby('data').agg({
                value_col: 'sum',
                **{col: 'mean' for col in df.columns if col not in ['data', value_col] and df[col].dtype in ['float64', 'int64']}
            }).reset_index()
        
        # Verificar continuidade temporal
        date_range = pd.date_range(df['data'].min(), df['data'].max(), freq='D')
        missing_dates = set(date_range) - set(df['data'])
        
        if missing_dates:
            st.info(f"‚ÑπÔ∏è {len(missing_dates)} datas faltantes no per√≠odo. Preenchendo com interpola√ß√£o.")
            
            # Criar s√©rie completa
            complete_df = pd.DataFrame({'data': date_range})
            df = complete_df.merge(df, on='data', how='left')
            
            # Interpola√ß√£o linear para vendas
            df[value_col] = df[value_col].interpolate(method='linear')
        
        # Adicionar features temporais
        df = self._add_time_features(df)
        
        return df
    
    def _add_time_features(self, df):
        """Adiciona features temporais ao dataset"""
        
        df = df.copy()
        df['ano'] = df['data'].dt.year
        df['mes'] = df['data'].dt.month
        df['dia'] = df['data'].dt.day
        df['dia_semana'] = df['data'].dt.dayofweek
        df['dia_ano'] = df['data'].dt.dayofyear
        df['semana'] = df['data'].dt.isocalendar().week
        df['trimestre'] = df['data'].dt.quarter
        df['eh_weekend'] = df['dia_semana'].isin([5, 6])
        
        # Nomes dos dias e meses
        df['nome_dia'] = df['dia_semana'].map({
            0: 'Segunda', 1: 'Ter√ßa', 2: 'Quarta', 3: 'Quinta',
            4: 'Sexta', 5: 'S√°bado', 6: 'Domingo'
        })
        
        df['nome_mes'] = df['mes'].map({
            1: 'Janeiro', 2: 'Fevereiro', 3: 'Mar√ßo', 4: 'Abril',
            5: 'Maio', 6: 'Junho', 7: 'Julho', 8: 'Agosto',
            9: 'Setembro', 10: 'Outubro', 11: 'Novembro', 12: 'Dezembro'
        })
        
        return df
    
    def _render_overview(self, df, value_col, store_name):
        """Renderiza vis√£o geral da s√©rie temporal"""
        
        st.subheader(f"üìä S√©rie Temporal - {store_name}")
        
        # Estat√≠sticas b√°sicas
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("üìÖ Total de Observa√ß√µes", len(df))
        
        with col2:
            period_days = (df['data'].max() - df['data'].min()).days
            st.metric("üìä Per√≠odo (dias)", period_days)
        
        with col3:
            mean_sales = df[value_col].mean()
            st.metric("üí∞ Vendas M√©dias", f"R$ {mean_sales:,.2f}".replace(',', '.'))
        
        with col4:
            cv = df[value_col].std() / df[value_col].mean()
            st.metric("üìà Coef. Varia√ß√£o", f"{cv:.3f}")
        
        # S√©rie temporal principal
        fig = go.Figure()
        
        fig.add_trace(go.Scatter(
            x=df['data'],
            y=df[value_col],
            mode='lines',
            name='Vendas',
            line=dict(color='blue', width=1)
        ))
        
        # Adicionar m√©dia m√≥vel
        window_size = min(30, len(df) // 10)
        if window_size >= 7:
            df['media_movel'] = df[value_col].rolling(window=window_size).mean()
            
            fig.add_trace(go.Scatter(
                x=df['data'],
                y=df['media_movel'],
                mode='lines',
                name=f'M√©dia M√≥vel ({window_size}d)',
                line=dict(color='red', width=2)
            ))
        
        fig.update_layout(
            title="S√©rie Temporal de Vendas",
            xaxis_title="Data",
            yaxis_title="Vendas (R$)",
            height=500,
            hovermode='x unified'
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Estat√≠sticas descritivas
        st.subheader("üìä Estat√≠sticas Descritivas")
        
        col1, col2 = st.columns(2)
        
        with col1:
            stats_data = {
                'M√©trica': ['M√©dia', 'Mediana', 'Desvio Padr√£o', 'M√≠nimo', 'M√°ximo', 
                           'Q1 (25%)', 'Q3 (75%)', 'Assimetria', 'Curtose'],
                'Valor': [
                    f"R$ {df[value_col].mean():,.2f}",
                    f"R$ {df[value_col].median():,.2f}",
                    f"R$ {df[value_col].std():,.2f}",
                    f"R$ {df[value_col].min():,.2f}",
                    f"R$ {df[value_col].max():,.2f}",
                    f"R$ {df[value_col].quantile(0.25):,.2f}",
                    f"R$ {df[value_col].quantile(0.75):,.2f}",
                    f"{df[value_col].skew():.3f}",
                    f"{df[value_col].kurtosis():.3f}"
                ]
            }
            
            stats_df = pd.DataFrame(stats_data)
            st.dataframe(stats_df, use_container_width=True, hide_index=True)
        
        with col2:
            # Histograma das vendas
            fig_hist = px.histogram(
                df,
                x=value_col,
                nbins=30,
                title="Distribui√ß√£o das Vendas",
                labels={value_col: 'Vendas (R$)', 'count': 'Frequ√™ncia'}
            )
            st.plotly_chart(fig_hist, use_container_width=True)
        
        # Teste de estacionariedade
        st.subheader("üîç Teste de Estacionariedade (Augmented Dickey-Fuller)")
        
        try:
            result = adfuller(df[value_col].dropna())
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("üìä Estat√≠stica ADF", f"{result[0]:.4f}")
            
            with col2:
                st.metric("üìà p-valor", f"{result[1]:.4f}")
            
            with col3:
                is_stationary = result[1] < 0.05
                status = "Estacion√°ria" if is_stationary else "N√£o-Estacion√°ria"
                st.metric("‚úÖ Status", status)
            
            if result[1] < 0.05:
                st.success("‚úÖ **S√©rie Estacion√°ria**: A s√©rie n√£o possui tend√™ncia ou sazonalidade forte.")
            else:
                st.warning("‚ö†Ô∏è **S√©rie N√£o-Estacion√°ria**: A s√©rie possui tend√™ncia ou sazonalidade. Considere diferencia√ß√£o.")
            
        except Exception as e:
            st.error(f"‚ùå Erro no teste de estacionariedade: {e}")
        
        # Identifica√ß√£o de outliers
        self._identify_outliers(df, value_col)
    
    def _identify_outliers(self, df, value_col):
        """Identifica e visualiza outliers na s√©rie temporal"""
        
        st.subheader("üéØ Identifica√ß√£o de Outliers")
        
        # M√©todo IQR
        Q1 = df[value_col].quantile(0.25)
        Q3 = df[value_col].quantile(0.75)
        IQR = Q3 - Q1
        
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        
        outliers = df[(df[value_col] < lower_bound) | (df[value_col] > upper_bound)]
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("üìä Total Outliers", len(outliers))
        
        with col2:
            outlier_pct = (len(outliers) / len(df)) * 100
            st.metric("üìà % Outliers", f"{outlier_pct:.1f}%")
        
        with col3:
            if len(outliers) > 0:
                avg_deviation = abs(outliers[value_col] - df[value_col].median()).mean()
                st.metric("üìä Desvio M√©dio", f"R$ {avg_deviation:,.2f}")
        
        if len(outliers) > 0:
            # Visualizar outliers
            fig_outliers = go.Figure()
            
            fig_outliers.add_trace(go.Scatter(
                x=df['data'],
                y=df[value_col],
                mode='lines+markers',
                name='Vendas',
                marker=dict(color='blue', size=4),
                line=dict(color='blue', width=1)
            ))
            
            fig_outliers.add_trace(go.Scatter(
                x=outliers['data'],
                y=outliers[value_col],
                mode='markers',
                name='Outliers',
                marker=dict(color='red', size=8, symbol='x')
            ))
            
            fig_outliers.update_layout(
                title="Identifica√ß√£o de Outliers",
                xaxis_title="Data",
                yaxis_title="Vendas (R$)",
                height=400
            )
            
            st.plotly_chart(fig_outliers, use_container_width=True)
            
            # Tabela dos outliers
            if len(outliers) <= 20:
                st.write("**Outliers Detectados:**")
                outliers_display = outliers[['data', value_col]].copy()
                outliers_display['data'] = outliers_display['data'].dt.strftime('%d/%m/%Y')
                outliers_display[value_col] = outliers_display[value_col].apply(lambda x: f"R$ {x:,.2f}")
                st.dataframe(outliers_display, use_container_width=True, hide_index=True)
            else:
                st.write(f"**{len(outliers)} outliers detectados** (exibindo apenas os primeiros 10)")
                outliers_display = outliers[['data', value_col]].head(10).copy()
                outliers_display['data'] = outliers_display['data'].dt.strftime('%d/%m/%Y')
                outliers_display[value_col] = outliers_display[value_col].apply(lambda x: f"R$ {x:,.2f}")
                st.dataframe(outliers_display, use_container_width=True, hide_index=True)
    
    def _render_decomposition(self, df, value_col):
        """Renderiza decomposi√ß√£o da s√©rie temporal"""
        
        st.subheader("üîç Decomposi√ß√£o da S√©rie Temporal")
        
        # Configura√ß√µes da decomposi√ß√£o
        col1, col2 = st.columns(2)
        
        with col1:
            model_type = st.selectbox("Tipo de Modelo:", ["additive", "multiplicative"])
        
        with col2:
            # Calcular per√≠odo baseado na frequ√™ncia dos dados
            period = st.slider("Per√≠odo de Sazonalidade:", 7, 365, 30)
        
        try:
            # Realizar decomposi√ß√£o
            decomposition = seasonal_decompose(
                df[value_col].dropna(), 
                model=model_type, 
                period=period
            )
            
            # Criar subplots
            fig = make_subplots(
                rows=4, cols=1,
                subplot_titles=['S√©rie Original', 'Tend√™ncia', 'Sazonalidade', 'Res√≠duos'],
                vertical_spacing=0.05
            )
            
            # S√©rie original
            fig.add_trace(
                go.Scatter(x=df['data'], y=df[value_col], name='Original', line=dict(color='blue')),
                row=1, col=1
            )
            
            # Tend√™ncia
            fig.add_trace(
                go.Scatter(x=df['data'], y=decomposition.trend, name='Tend√™ncia', line=dict(color='red')),
                row=2, col=1
            )
            
            # Sazonalidade
            fig.add_trace(
                go.Scatter(x=df['data'], y=decomposition.seasonal, name='Sazonalidade', line=dict(color='green')),
                row=3, col=1
            )
            
            # Res√≠duos
            fig.add_trace(
                go.Scatter(x=df['data'], y=decomposition.resid, name='Res√≠duos', line=dict(color='orange')),
                row=4, col=1
            )
            
            fig.update_layout(
                height=800,
                title_text=f"Decomposi√ß√£o {model_type.title()} da S√©rie Temporal",
                showlegend=False
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # An√°lise dos componentes
            st.subheader("üìä An√°lise dos Componentes")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                trend_strength = 1 - (decomposition.resid.var() / df[value_col].var())
                st.metric("üìà For√ßa da Tend√™ncia", f"{trend_strength:.3f}")
            
            with col2:
                seasonal_strength = 1 - (decomposition.resid.var() / (df[value_col] - decomposition.trend).var())
                st.metric("üîÑ For√ßa da Sazonalidade", f"{seasonal_strength:.3f}")
            
            with col3:
                residual_var = decomposition.resid.var()
                st.metric("üìä Vari√¢ncia Res√≠duos", f"{residual_var:.2f}")
            
            # Interpreta√ß√£o
            interpretations = []
            
            if trend_strength > 0.6:
                interpretations.append("üìà **Tend√™ncia Forte**: A s√©rie apresenta uma tend√™ncia bem definida.")
            elif trend_strength > 0.3:
                interpretations.append("üìä **Tend√™ncia Moderada**: A s√©rie apresenta alguma tend√™ncia.")
            else:
                interpretations.append("‚û°Ô∏è **Tend√™ncia Fraca**: A s√©rie n√£o apresenta tend√™ncia clara.")
            
            if seasonal_strength > 0.6:
                interpretations.append("üîÑ **Sazonalidade Forte**: Padr√µes sazonais bem definidos.")
            elif seasonal_strength > 0.3:
                interpretations.append("üìä **Sazonalidade Moderada**: Alguns padr√µes sazonais presentes.")
            else:
                interpretations.append("‚û°Ô∏è **Sazonalidade Fraca**: Pouco padr√£o sazonal detectado.")
            
            for interpretation in interpretations:
                st.info(interpretation)
            
        except Exception as e:
            st.error(f"‚ùå Erro na decomposi√ß√£o: {e}")
            st.info("üí° Tente ajustar o per√≠odo de sazonalidade ou verificar se h√° dados suficientes.")
    
    def _render_trend_analysis(self, df, value_col):
        """Renderiza an√°lise de tend√™ncias"""
        
        st.subheader("üìà An√°lise de Tend√™ncias")
        
        # An√°lise de tend√™ncia linear
        from scipy.stats import linregress
        
        # Criar √≠ndice num√©rico
        x = np.arange(len(df))
        y = df[value_col].values
        
        slope, intercept, r_value, p_value, std_err = linregress(x, y)
        
        # M√©tricas da tend√™ncia
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("üìà Inclina√ß√£o", f"{slope:.2f} R$/dia")
        
        with col2:
            st.metric("üìä R¬≤", f"{r_value**2:.4f}")
        
        with col3:
            st.metric("üìà p-valor", f"{p_value:.4f}")
        
        with col4:
            trend_direction = "Crescente" if slope > 0 else "Decrescente" if slope < 0 else "Est√°vel"
            st.metric("üéØ Dire√ß√£o", trend_direction)
        
        # Visualiza√ß√£o da tend√™ncia
        trend_line = slope * x + intercept
        
        fig = go.Figure()
        
        fig.add_trace(go.Scatter(
            x=df['data'],
            y=df[value_col],
            mode='lines',
            name='Vendas',
            line=dict(color='blue', width=1)
        ))
        
        fig.add_trace(go.Scatter(
            x=df['data'],
            y=trend_line,
            mode='lines',
            name='Tend√™ncia Linear',
            line=dict(color='red', width=3, dash='dash')
        ))
        
        fig.update_layout(
            title="An√°lise de Tend√™ncia Linear",
            xaxis_title="Data",
            yaxis_title="Vendas (R$)",
            height=500
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Interpreta√ß√£o da tend√™ncia
        if p_value < 0.05:
            if slope > 0:
                st.success(f"‚úÖ **Tend√™ncia Crescente Significativa**: As vendas aumentam em m√©dia R$ {slope:.2f} por dia.")
            else:
                st.warning(f"‚ö†Ô∏è **Tend√™ncia Decrescente Significativa**: As vendas diminuem em m√©dia R$ {abs(slope):.2f} por dia.")
        else:
            st.info("‚ÑπÔ∏è **Sem Tend√™ncia Significativa**: N√£o h√° evid√™ncia estat√≠stica de tend√™ncia linear.")
        
        # An√°lise de tend√™ncia por per√≠odos
        st.subheader("üìä Tend√™ncia por Per√≠odos")
        
        # An√°lise mensal
        monthly_trend = df.groupby(['ano', 'mes'])[value_col].mean().reset_index()
        monthly_trend['periodo'] = monthly_trend['ano'].astype(str) + '-' + monthly_trend['mes'].astype(str).str.zfill(2)
        
        fig_monthly = px.line(
            monthly_trend,
            x='periodo',
            y=value_col,
            title="Vendas M√©dias Mensais",
            labels={'periodo': 'Per√≠odo (Ano-M√™s)', value_col: 'Vendas M√©dias (R$)'}
        )
        fig_monthly.update_xaxes(tickangle=45)
        st.plotly_chart(fig_monthly, use_container_width=True)
        
        # An√°lise trimestral
        quarterly_trend = df.groupby(['ano', 'trimestre'])[value_col].mean().reset_index()
        quarterly_trend['periodo'] = quarterly_trend['ano'].astype(str) + '-Q' + quarterly_trend['trimestre'].astype(str)
        
        fig_quarterly = px.bar(
            quarterly_trend,
            x='periodo',
            y=value_col,
            title="Vendas M√©dias Trimestrais",
            labels={'periodo': 'Per√≠odo', value_col: 'Vendas M√©dias (R$)'}
        )
        st.plotly_chart(fig_quarterly, use_container_width=True)
        
        # Detec√ß√£o de pontos de mudan√ßa
        self._detect_change_points(df, value_col)
    
    def _detect_change_points(self, df, value_col):
        """Detecta pontos de mudan√ßa na s√©rie temporal"""
        
        st.subheader("üîÑ Detec√ß√£o de Pontos de Mudan√ßa")
        
        try:
            # M√©todo simples de detec√ß√£o de mudan√ßa usando diferen√ßas
            window = min(30, len(df) // 10)
            
            if window < 5:
                st.warning("‚ö†Ô∏è Dados insuficientes para detec√ß√£o de pontos de mudan√ßa")
                return
            
            # Calcular m√©dia m√≥vel e desvio padr√£o
            rolling_mean = df[value_col].rolling(window=window).mean()
            rolling_std = df[value_col].rolling(window=window).std()
            
            # Identificar pontos onde a s√©rie sai do intervalo de confian√ßa
            upper_bound = rolling_mean + 2 * rolling_std
            lower_bound = rolling_mean - 2 * rolling_std
            
            change_points = df[
                (df[value_col] > upper_bound) | 
                (df[value_col] < lower_bound)
            ]
            
            if len(change_points) > 0:
                st.write(f"**{len(change_points)} pontos de mudan√ßa detectados:**")
                
                fig = go.Figure()
                
                fig.add_trace(go.Scatter(
                    x=df['data'],
                    y=df[value_col],
                    mode='lines',
                    name='Vendas',
                    line=dict(color='blue', width=1)
                ))
                
                fig.add_trace(go.Scatter(
                    x=df['data'],
                    y=rolling_mean,
                    mode='lines',
                    name='M√©dia M√≥vel',
                    line=dict(color='green', width=2)
                ))
                
                fig.add_trace(go.Scatter(
                    x=df['data'],
                    y=upper_bound,
                    mode='lines',
                    name='Limite Superior',
                    line=dict(color='red', dash='dash')
                ))
                
                fig.add_trace(go.Scatter(
                    x=df['data'],
                    y=lower_bound,
                    mode='lines',
                    name='Limite Inferior',
                    line=dict(color='red', dash='dash')
                ))
                
                fig.add_trace(go.Scatter(
                    x=change_points['data'],
                    y=change_points[value_col],
                    mode='markers',
                    name='Pontos de Mudan√ßa',
                    marker=dict(color='orange', size=8, symbol='diamond')
                ))
                
                fig.update_layout(
                    title="Detec√ß√£o de Pontos de Mudan√ßa",
                    xaxis_title="Data",
                    yaxis_title="Vendas (R$)",
                    height=500
                )
                
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("‚ÑπÔ∏è Nenhum ponto de mudan√ßa significativo detectado")
                
        except Exception as e:
            st.error(f"‚ùå Erro na detec√ß√£o de pontos de mudan√ßa: {e}")
    
    def _render_seasonality_analysis(self, df, value_col):
        """Renderiza an√°lise de sazonalidade"""
        
        st.subheader("üîÑ An√°lise de Sazonalidade")
        
        # An√°lise por dia da semana
        weekday_analysis = df.groupby('nome_dia')[value_col].agg(['mean', 'std', 'count']).round(2)
        weekday_analysis = weekday_analysis.reindex([
            'Segunda', 'Ter√ßa', 'Quarta', 'Quinta', 'Sexta', 'S√°bado', 'Domingo'
        ])
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**üìÖ Vendas por Dia da Semana:**")
            st.dataframe(weekday_analysis, use_container_width=True)
        
        with col2:
            fig_weekday = px.bar(
                x=weekday_analysis.index,
                y=weekday_analysis['mean'],
                error_y=weekday_analysis['std'],
                title="Vendas M√©dias por Dia da Semana",
                labels={'x': 'Dia da Semana', 'y': 'Vendas M√©dias (R$)'}
            )
            st.plotly_chart(fig_weekday, use_container_width=True)
        
        # An√°lise por m√™s
        monthly_analysis = df.groupby('nome_mes')[value_col].agg(['mean', 'std', 'count']).round(2)
        month_order = ['Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho',
                      'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro']
        available_months = [m for m in month_order if m in monthly_analysis.index]
        monthly_analysis = monthly_analysis.reindex(available_months)
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**üìÖ Vendas por M√™s:**")
            st.dataframe(monthly_analysis, use_container_width=True)
        
        with col2:
            fig_monthly = px.line(
                x=monthly_analysis.index,
                y=monthly_analysis['mean'],
                title="Padr√£o Sazonal Mensal",
                labels={'x': 'M√™s', 'y': 'Vendas M√©dias (R$)'}
            )
            fig_monthly.update_xaxes(tickangle=45)
            st.plotly_chart(fig_monthly, use_container_width=True)
        
        # An√°lise de sazonalidade avan√ßada
        st.subheader("üìä An√°lise de Sazonalidade Avan√ßada")
        
        # Boxplot por trimestre
        fig_quarterly = px.box(
            df,
            x='trimestre',
            y=value_col,
            title="Distribui√ß√£o de Vendas por Trimestre",
            labels={'trimestre': 'Trimestre', value_col: 'Vendas (R$)'}
        )
        st.plotly_chart(fig_quarterly, use_container_width=True)
        
        # Heatmap sazonal
        if len(df) > 100:  # S√≥ fazer se houver dados suficientes
            
            # Criar pivot para heatmap
            df['semana_ano'] = df['data'].dt.isocalendar().week
            
            # Limitar a an√°lise se houver muitos dados
            if len(df['semana_ano'].unique()) > 53:
                recent_data = df.tail(365)  # √öltimo ano de dados
            else:
                recent_data = df
            
            pivot_data = recent_data.pivot_table(
                values=value_col,
                index='semana_ano',
                columns='dia_semana',
                aggfunc='mean'
            )
            
            if not pivot_data.empty:
                fig_heatmap = px.imshow(
                    pivot_data,
                    labels=dict(x="Dia da Semana", y="Semana do Ano", color="Vendas (R$)"),
                    title="Heatmap Sazonal: Vendas por Semana e Dia",
                    color_continuous_scale='viridis'
                )
                
                fig_heatmap.update_xaxes(
                    tickvals=list(range(7)),
                    ticktext=['Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'S√°b', 'Dom']
                )
                
                st.plotly_chart(fig_heatmap, use_container_width=True)
        
        # Testes estat√≠sticos de sazonalidade
        self._test_seasonality(df, value_col)
    
    def _test_seasonality(self, df, value_col):
        """Testa estatisticamente a presen√ßa de sazonalidade"""
        
        st.subheader("üîç Testes de Sazonalidade")
        
        try:
            # Teste Kruskal-Wallis para diferen√ßas por dia da semana
            groups = [df[df['dia_semana'] == day][value_col] for day in range(7)]
            groups = [group for group in groups if len(group) > 0]
            
            if len(groups) >= 2:
                kruskal_stat, kruskal_p = stats.kruskal(*groups)
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.metric("üìä Kruskal-Wallis (Dias)", f"{kruskal_stat:.4f}")
                
                with col2:
                    st.metric("üìà p-valor", f"{kruskal_p:.4f}")
                
                if kruskal_p < 0.05:
                    st.success("‚úÖ **Sazonalidade Semanal Significativa**: H√° diferen√ßas estat√≠sticas entre os dias da semana.")
                else:
                    st.info("‚ÑπÔ∏è **Sem Sazonalidade Semanal**: N√£o h√° diferen√ßas significativas entre os dias da semana.")
            
            # Teste para sazonalidade mensal (se houver dados suficientes)
            if len(df['mes'].unique()) >= 3:
                monthly_groups = [df[df['mes'] == month][value_col] for month in df['mes'].unique()]
                monthly_groups = [group for group in monthly_groups if len(group) > 0]
                
                if len(monthly_groups) >= 3:
                    monthly_kruskal_stat, monthly_kruskal_p = stats.kruskal(*monthly_groups)
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.metric("üìä Kruskal-Wallis (Meses)", f"{monthly_kruskal_stat:.4f}")
                    
                    with col2:
                        st.metric("üìà p-valor", f"{monthly_kruskal_p:.4f}")
                    
                    if monthly_kruskal_p < 0.05:
                        st.success("‚úÖ **Sazonalidade Mensal Significativa**: H√° diferen√ßas estat√≠sticas entre os meses.")
                    else:
                        st.info("‚ÑπÔ∏è **Sem Sazonalidade Mensal**: N√£o h√° diferen√ßas significativas entre os meses.")
            
        except Exception as e:
            st.error(f"‚ùå Erro nos testes de sazonalidade: {e}")
    
    def _render_autocorrelation_analysis(self, df, value_col):
        """Renderiza an√°lise de autocorrela√ß√£o"""
        
        st.subheader("üìâ An√°lise de Autocorrela√ß√£o")
        
        try:
            # Calcular ACF e PACF
            max_lags = min(50, len(df) // 4)
            
            acf_values = acf(df[value_col].dropna(), nlags=max_lags, alpha=0.05)
            pacf_values = pacf(df[value_col].dropna(), nlags=max_lags, alpha=0.05)
            
            # Gr√°fico ACF
            col1, col2 = st.columns(2)
            
            with col1:
                lags = range(len(acf_values[0]))
                
                fig_acf = go.Figure()
                
                fig_acf.add_trace(go.Bar(
                    x=list(lags),
                    y=acf_values[0],
                    name='ACF',
                    marker_color='blue'
                ))
                
                # Adicionar bandas de confian√ßa
                if len(acf_values) > 1:
                    fig_acf.add_trace(go.Scatter(
                        x=list(lags),
                        y=acf_values[1][:, 0],
                        mode='lines',
                        name='IC Inferior',
                        line=dict(color='red', dash='dash')
                    ))
                    
                    fig_acf.add_trace(go.Scatter(
                        x=list(lags),
                        y=acf_values[1][:, 1],
                        mode='lines',
                        name='IC Superior',
                        line=dict(color='red', dash='dash')
                    ))
                
                fig_acf.update_layout(
                    title="Fun√ß√£o de Autocorrela√ß√£o (ACF)",
                    xaxis_title="Lag",
                    yaxis_title="Autocorrela√ß√£o",
                    height=400
                )
                
                st.plotly_chart(fig_acf, use_container_width=True)
            
            with col2:
                lags = range(len(pacf_values[0]))
                
                fig_pacf = go.Figure()
                
                fig_pacf.add_trace(go.Bar(
                    x=list(lags),
                    y=pacf_values[0],
                    name='PACF',
                    marker_color='green'
                ))
                
                # Adicionar bandas de confian√ßa
                if len(pacf_values) > 1:
                    fig_pacf.add_trace(go.Scatter(
                        x=list(lags),
                        y=pacf_values[1][:, 0],
                        mode='lines',
                        name='IC Inferior',
                        line=dict(color='red', dash='dash')
                    ))
                    
                    fig_pacf.add_trace(go.Scatter(
                        x=list(lags),
                        y=pacf_values[1][:, 1],
                        mode='lines',
                        name='IC Superior',
                        line=dict(color='red', dash='dash')
                    ))
                
                fig_pacf.update_layout(
                    title="Fun√ß√£o de Autocorrela√ß√£o Parcial (PACF)",
                    xaxis_title="Lag",
                    yaxis_title="Autocorrela√ß√£o Parcial",
                    height=400
                )
                
                st.plotly_chart(fig_pacf, use_container_width=True)
            
            # Interpreta√ß√£o dos resultados
            st.subheader("üí° Interpreta√ß√£o da Autocorrela√ß√£o")
            
            interpretations = []
            
            # Verificar autocorrela√ß√£o significativa
            significant_acf_lags = []
            if len(acf_values) > 1:
                for i, (acf_val, (lower, upper)) in enumerate(zip(acf_values[0][1:], acf_values[1][1:]), 1):
                    if acf_val < lower or acf_val > upper:
                        significant_acf_lags.append(i)
            
            if significant_acf_lags:
                if 1 in significant_acf_lags:
                    interpretations.append("üìà **Autocorrela√ß√£o de Lag 1**: Valor de hoje influencia o valor de amanh√£.")
                
                if any(lag in [7, 14, 21, 28] for lag in significant_acf_lags):
                    interpretations.append("üìÖ **Padr√£o Semanal**: Autocorrela√ß√£o em m√∫ltiplos de 7 dias detectada.")
                
                if any(lag >= 30 for lag in significant_acf_lags):
                    interpretations.append("üìä **Padr√£o de Longo Prazo**: Autocorrela√ß√£o de longo prazo detectada.")
            
            if not interpretations:
                interpretations.append("‚û°Ô∏è **Baixa Autocorrela√ß√£o**: A s√©rie apresenta pouca depend√™ncia temporal.")
            
            for interpretation in interpretations:
                st.info(interpretation)
            
            # Tabela com valores significativos
            if significant_acf_lags:
                st.write("**üìä Lags com Autocorrela√ß√£o Significativa:**")
                
                significant_data = []
                for lag in significant_acf_lags[:10]:  # Limitar a 10 lags
                    significant_data.append({
                        'Lag': lag,
                        'ACF': f"{acf_values[0][lag]:.4f}",
                        'Significativo': '‚úÖ'
                    })
                
                sig_df = pd.DataFrame(significant_data)
                st.dataframe(sig_df, use_container_width=True, hide_index=True)
            
        except Exception as e:
            st.error(f"‚ùå Erro na an√°lise de autocorrela√ß√£o: {e}")

# Fun√ß√£o para integrar com streamlit_app.py
def show_serie_temporal_page(df, role, store_manager):
    """Fun√ß√£o para mostrar a p√°gina de s√©rie temporal"""
    
    page = SerieTemporalPage(store_manager)
    page.render()